"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const optional_js_1 = tslib_1.__importDefault(require("optional-js"));
const morpheus_crypto_1 = require("@internet-of-people/morpheus-crypto");
const optional_1 = require("./optional");
class DidDocument {
    constructor(data) {
        this.data = data;
        this.keys = [];
        this.fromData(data);
    }
    hasRightAt(auth, right, height) {
        this.ensureHeightIsKnown(height);
        const rightHistories = this.data.rights[right] || [];
        for (const rightHistory of rightHistories) {
            const idx = this.getKeyIdx(rightHistory.keyLink);
            const keyData = this.data.keys[idx];
            if (!this.isKeyValidAt(keyData, height)) {
                continue;
            }
            if (!morpheus_crypto_1.isSameAuthentication(this.keys[idx], auth)) {
                continue;
            }
            const rightValid = this.isRightValidAt(rightHistory.history, height);
            return rightValid;
        }
        return false;
    }
    isTombstonedAt(height) {
        this.ensureHeightIsKnown(height);
        if (this.data.tombstonedAtHeight && height >= this.data.tombstonedAtHeight) {
            return true;
        }
        return false;
    }
    fromData(data) {
        this.data = data; // TODO consider if we should clone here or is this OK
        this.keys = data.keys.map((keyData) => {
            return morpheus_crypto_1.authenticationFromData(keyData.auth);
        });
    }
    toData() {
        return this.data; // TODO consider if we should clone here or is this OK
    }
    get height() {
        return this.data.queriedAtHeight;
    }
    get did() {
        return new morpheus_crypto_1.Did(this.data.did);
    }
    ensureHeightIsKnown(height) {
        if (height > this.height) {
            throw new Error(`Cannot query at ${height}, latest block seen was ${this.height}`);
        }
    }
    isKeyValidAt(key, height) {
        return optional_1.isHeightInRangeExclUntil(height, optional_js_1.default.ofNullable(key.validFromHeight), optional_js_1.default.ofNullable(key.validUntilHeight));
    }
    isRightValidAt(points, height) {
        let validAtHeight = false;
        for (const point of points) {
            if (point.height && point.height > height) {
                break;
            }
            validAtHeight = point.valid;
        }
        return validAtHeight;
    }
    getKeyIdx(keyLink) {
        if (!keyLink.startsWith('#')) {
            throw new Error(`Only did-internal keyLinks are supported yet. Found ${keyLink}`);
        }
        const idx = Number(keyLink.substring(1));
        if (!Number.isSafeInteger(idx)) {
            throw new Error(`Invalid did-internal keyLink found: ${keyLink}`);
        }
        return idx;
    }
}
exports.DidDocument = DidDocument;
//# sourceMappingURL=did-document.js.map