"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const morpheus_crypto_1 = require("@internet-of-people/morpheus-crypto");
const operation_1 = require("../operation");
const operation_type_1 = require("../operation-type");
const serde_1 = require("../serde");
const from_data_1 = require("./from-data");
class Signed extends operation_1.Operation {
    constructor(operations) {
        super();
        this.operations = operations;
    }
    get type() {
        return operation_type_1.OperationType.Signed;
    }
    static getOperationsUnsafeWithoutSignatureChecking(data) {
        return data.signables.map(from_data_1.fromSignableData);
    }
    static getOperations(data) {
        const signableBytes = Signed.serialize(data.signables);
        const signedBytes = new morpheus_crypto_1.SignedBytes(new morpheus_crypto_1.PublicKey(data.signerPublicKey), signableBytes, new morpheus_crypto_1.Signature(data.signature));
        if (!signedBytes.validate()) {
            throw new Error('Invalid signature');
        }
        return Signed.getOperationsUnsafeWithoutSignatureChecking(data);
    }
    static serialize(ops) {
        // Note: stringify is required here to keep the JSON serialization strict in order
        const buffer = serde_1.toBuffer(JSON.parse(morpheus_crypto_1.stringifyJson(ops)));
        buffer.flip();
        const bytes = Uint8Array.from(buffer.toBuffer());
        return bytes;
    }
    accept(visitor) {
        return visitor.signed(this.operations);
    }
}
exports.Signed = Signed;
//# sourceMappingURL=operation.js.map