"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const optional_js_1 = tslib_1.__importDefault(require("optional-js"));
const morpheus_crypto_1 = require("@internet-of-people/morpheus-crypto");
const http_1 = require("../../internal/http");
class AxiosClient {
    constructor(networkConfig) {
        this.networkConfig = networkConfig;
        const baseURL = `${networkConfig.host}:${networkConfig.port}/api/v2`;
        this.clientInstance = axios_1.default.create({
            baseURL,
            headers: {
                'Content-Type': 'application/json',
            },
        });
    }
    async sendTx(tx) {
        morpheus_crypto_1.log('Sending tx...');
        const resp = await http_1.apiPost(this.clientInstance, '/transactions', JSON.stringify({ transactions: [tx] }));
        if (resp.data.data.invalid && resp.data.data.invalid.length > 0) {
            /* eslint no-undefined: 0 */
            throw new Error(`Transaction failed: ${JSON.stringify(resp.data.errors, undefined, 2)}`);
        }
        const { accept } = resp.data.data;
        if (accept.length !== 1) {
            /* eslint no-undefined: 0 */
            throw new Error(`sendTx expected 1 accepted tx, got ${accept.length}. Response: ${JSON.stringify(resp.data, undefined, 2)}`);
        }
        morpheus_crypto_1.log('Tx sent, id:', accept[0]);
        return accept[0];
    }
    async sendMultipleTx(transactions) {
        morpheus_crypto_1.log('Sending txns...');
        const resp = await http_1.apiPost(this.clientInstance, '/transactions', JSON.stringify({ transactions }));
        if (resp.data.data.invalid && resp.data.data.invalid.length > 0) {
            /* eslint no-undefined: 0 */
            throw new Error(`Transaction failed: ${JSON.stringify(resp.data.errors, undefined, 2)}`);
        }
        const { accept, invalid } = resp.data.data;
        morpheus_crypto_1.log('Tx sent, id:', accept[0]);
        const result = {
            accept,
            invalid,
        };
        if (invalid.length > 0) {
            result.errorResponse = JSON.stringify(resp.data, undefined, 2);
        }
        return result;
    }
    async getTxnStatus(txId) {
        morpheus_crypto_1.log(`Getting txn layer1 status for ${txId}...`);
        try {
            const resp = await http_1.apiGet(this.clientInstance, `/transactions/${txId}`);
            return optional_js_1.default.of(resp.data.data);
        }
        catch (e) {
            if (e instanceof http_1.HttpError && e.statusCode === 404) {
                return optional_js_1.default.empty();
            }
            throw e;
        }
    }
    async getWallet(address) {
        morpheus_crypto_1.log(`Getting wallet of ${address}...`);
        try {
            const resp = await http_1.apiGet(this.clientInstance, `/wallets/${address}`);
            return optional_js_1.default.of(resp.data.data);
        }
        catch (e) {
            if (e instanceof http_1.HttpError && e.statusCode === 404) {
                morpheus_crypto_1.log(`Could not get wallet for ${address}, probably a cold wallet.`);
                morpheus_crypto_1.log(`Balance of ${address} is 0`);
                return optional_js_1.default.empty();
            }
            throw e;
        }
    }
    async getWalletNonce(address) {
        morpheus_crypto_1.log(`Getting wallet nonce of ${address}...`);
        const wallet = await this.getWallet(address);
        if (wallet.isPresent()) {
            const nonce = BigInt(wallet.get().nonce);
            morpheus_crypto_1.log(`Nonce of ${address} is ${nonce.toLocaleString()}`);
            return nonce;
        }
        morpheus_crypto_1.log(`Nonce of ${address} is 0`);
        return BigInt(0);
    }
    async getWalletBalance(address) {
        morpheus_crypto_1.log(`Getting wallet balance of ${address}...`);
        const wallet = await this.getWallet(address);
        if (wallet.isPresent()) {
            return BigInt(wallet.get().balance);
        }
        return BigInt(0);
    }
    async getNodeCryptoConfig() {
        morpheus_crypto_1.log('Getting node crypto config...');
        const resp = await http_1.apiGet(this.clientInstance, '/node/configuration/crypto');
        return resp.data.data;
    }
    async getCurrentHeight() {
        morpheus_crypto_1.log('Getting current height...');
        const resp = await http_1.apiGet(this.clientInstance, '/blockchain');
        const { height } = resp.data.data.block;
        morpheus_crypto_1.log(`Height is ${height}`);
        return height;
    }
}
exports.AxiosClient = AxiosClient;
//# sourceMappingURL=client.js.map