"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const crypto_1 = require("@arkecosystem/crypto");
const morpheus_crypto_1 = require("@internet-of-people/morpheus-crypto");
const transaction_1 = require("../transaction");
const Layer1 = tslib_1.__importStar(require("../../layer1"));
const Layer2 = tslib_1.__importStar(require("../../layer2"));
const client_1 = require("./client");
const coeus_wasm_1 = require("../../coeus-wasm");
class Api {
    constructor(clientInstance) {
        this.clientInstance = clientInstance;
    }
    async getNodeCryptoConfig() {
        return this.clientInstance.getNodeCryptoConfig();
    }
    async getCurrentHeight() {
        return this.clientInstance.getCurrentHeight();
    }
    async getTxnStatus(txId) {
        return this.clientInstance.getTxnStatus(txId);
    }
    async getWallet(address) {
        return this.clientInstance.getWallet(address);
    }
    async getWalletNonce(address) {
        return this.clientInstance.getWalletNonce(address);
    }
    async getWalletBalance(address) {
        return this.clientInstance.getWalletBalance(address);
    }
    // TODO Introduce a parameter object at least for the optional arguments
    /* eslint-disable-next-line max-params */
    async sendTransferTx(fromAddress, toAddress, amountFlake, hydraPrivate, nonce, vendorField, manualFee) {
        const { network } = hydraPrivate;
        const tx = new morpheus_crypto_1.HydraTxBuilder(network)
            .transfer(morpheus_crypto_1.SecpKeyId.fromAddress(toAddress, network), hydraPrivate.pub.keyByAddress(fromAddress).publicKey(), amountFlake, nonce !== null && nonce !== void 0 ? nonce : await this.nextHydraNonce(fromAddress), vendorField, manualFee);
        const signedTx = hydraPrivate.signHydraTransaction(fromAddress, tx);
        return this.clientInstance.sendTx(signedTx);
    }
    async sendTx(signedTx) {
        return this.clientInstance.sendTx(signedTx);
    }
    async sendMultipleTx(signedTxns) {
        return this.clientInstance.sendMultipleTx(signedTxns);
    }
    /* eslint-disable-next-line max-params */
    async sendVoteTx(fromAddress, delegate, hydraPrivate, nonce, vendorField, manualFee) {
        const { network } = hydraPrivate;
        const tx = new morpheus_crypto_1.HydraTxBuilder(network)
            .vote(delegate, hydraPrivate.pub.keyByAddress(fromAddress).publicKey(), nonce !== null && nonce !== void 0 ? nonce : await this.nextHydraNonce(fromAddress), vendorField, manualFee);
        const signedTx = hydraPrivate.signHydraTransaction(fromAddress, tx);
        return this.clientInstance.sendTx(signedTx);
    }
    /* eslint-disable-next-line max-params */
    async sendUnvoteTx(fromAddress, delegate, hydraPrivate, nonce, vendorField, manualFee) {
        const { network } = hydraPrivate;
        const tx = new morpheus_crypto_1.HydraTxBuilder(network)
            .unvote(delegate, hydraPrivate.pub.keyByAddress(fromAddress).publicKey(), nonce !== null && nonce !== void 0 ? nonce : await this.nextHydraNonce(fromAddress), vendorField, manualFee);
        const signedTx = hydraPrivate.signHydraTransaction(fromAddress, tx);
        return this.clientInstance.sendTx(signedTx);
    }
    /* eslint-disable-next-line max-params */
    async sendTransferTxWithWIF(fromWIF, toAddress, amountFlake, nonce, vendorField, manualFee) {
        const senderKeys = crypto_1.Identities.Keys.fromWIF(fromWIF);
        const address = crypto_1.Identities.Address.fromPublicKey(senderKeys.publicKey);
        const tx = await this.buildTransferTxWithAddress(address, toAddress, amountFlake, nonce, vendorField, manualFee);
        const signedTx = tx
            .signWithWif(fromWIF)
            .getStruct();
        return this.clientInstance.sendTx(signedTx);
    }
    /* eslint-disable-next-line max-params */
    async sendTransferTxWithPassphrase(fromPassphrase, toAddress, amountFlake, nonce, vendorField, manualFee) {
        const senderKeys = crypto_1.Identities.Keys.fromPassphrase(fromPassphrase);
        const address = crypto_1.Identities.Address.fromPublicKey(senderKeys.publicKey);
        const tx = await this.buildTransferTxWithAddress(address, toAddress, amountFlake, nonce, vendorField, manualFee);
        const signedTx = tx
            .sign(fromPassphrase)
            .build()
            .toJSON();
        return this.clientInstance.sendTx(signedTx);
    }
    async sendMorpheusTx(senderAddress, morpheusAsset, hydraPrivate, nonce) {
        const { network } = hydraPrivate;
        const nextNonce = nonce !== null && nonce !== void 0 ? nonce : await this.getGasNonceAndCheckBalance(senderAddress, nonce);
        const senderPubKey = hydraPrivate.pub.keyByAddress(senderAddress).publicKey();
        const unsignedTx = morpheus_crypto_1.MorpheusTxBuilder.build(network, morpheusAsset, senderPubKey, nextNonce);
        const signedTx = hydraPrivate.signHydraTransaction(senderAddress, unsignedTx);
        return this.clientInstance.sendTx(signedTx);
    }
    async sendMorpheusTxWithWIF(attempts, fromWIF, nonce) {
        const keys = crypto_1.Identities.Keys.fromWIF(fromWIF);
        const unsignedTx = await this.buildMorpheusTx(keys, attempts, nonce);
        const signedTx = unsignedTx
            .signWithWif(fromWIF)
            .getStruct();
        return this.clientInstance.sendTx(signedTx);
    }
    async sendMorpheusTxWithPassphrase(attempts, fromPassphrase, nonce) {
        const keys = crypto_1.Identities.Keys.fromPassphrase(fromPassphrase);
        const unsignedTx = await this.buildMorpheusTx(keys, attempts, nonce);
        const signedTx = unsignedTx
            .sign(fromPassphrase)
            .build()
            .toJson();
        return this.clientInstance.sendTx(signedTx);
    }
    async sendCoeusTx(fromAddress, userOperations, hydraPrivate, layer1SenderNonce, layer2PublicKeyNonce) {
        const { network } = hydraPrivate;
        const secpPubKey = hydraPrivate.pub.keyByAddress(fromAddress).publicKey();
        const secpPrivKey = hydraPrivate.keyByPublicKey(secpPubKey).privateKey();
        const pubKey = coeus_wasm_1.PublicKey.fromSecp(secpPubKey);
        const privKey = coeus_wasm_1.PrivateKey.fromSecp(secpPrivKey);
        const noncedBundleBuilder = new coeus_wasm_1.NoncedBundleBuilder();
        for (const userOperation of userOperations) {
            noncedBundleBuilder.add(userOperation);
        }
        const noncedBundle = noncedBundleBuilder.build(layer2PublicKeyNonce !== null && layer2PublicKeyNonce !== void 0 ? layer2PublicKeyNonce : await this.nextCoeusNonce(pubKey));
        const ops = noncedBundle.sign(privKey);
        const tx = new coeus_wasm_1.CoeusTxBuilder(network)
            .build(ops, secpPubKey, layer1SenderNonce !== null && layer1SenderNonce !== void 0 ? layer1SenderNonce : await this.nextHydraNonce(fromAddress));
        const signedTx = hydraPrivate.signHydraTransaction(fromAddress, tx);
        return this.clientInstance.sendTx(signedTx);
    }
    async nextHydraNonce(address) {
        const currentNonce = await this.clientInstance.getWalletNonce(address);
        const nextNonce = currentNonce + BigInt(1);
        morpheus_crypto_1.log(`Current nonce is ${currentNonce}, next nonce is ${nextNonce}`);
        return nextNonce;
    }
    // TODO: we have to get the coeus nonce from somewhere else rather using layer2api
    async nextCoeusNonce(pubKey) {
        const coeusApi = new Layer2.CoeusApi(this.clientInstance.networkConfig);
        const currentNonce = await coeusApi.getLastNonce(pubKey);
        const nextNonce = currentNonce + BigInt(1);
        return nextNonce;
    }
    async getGasNonceAndCheckBalance(address, nonce) {
        const wallet = await this.clientInstance.getWallet(address);
        const balance = wallet.isPresent() ? BigInt(wallet.get().balance) : BigInt(0);
        if (balance < BigInt('10000000')) { // 0.1 HYD in flakes (HYD*1e8)
            throw new Error('Low balance. Send some HYDs to the address you provided.');
        }
        let nextNonce = nonce;
        if (!nextNonce) {
            const currentNonce = wallet.isPresent() ? BigInt(wallet.get().nonce) : BigInt(0);
            nextNonce = currentNonce + BigInt(1);
            morpheus_crypto_1.log(`Current nonce is ${currentNonce}, next nonce is ${nextNonce}`);
        }
        return nextNonce;
    }
    async buildMorpheusTx(from, attempts, nonce) {
        const txBuilder = new Layer1.MorpheusTransactionBuilder();
        const unsignedTx = txBuilder.fromOperationAttempts(attempts);
        // checking balance
        const address = crypto_1.Identities.Address.fromPublicKey(from.publicKey);
        const nextNonce = await this.getGasNonceAndCheckBalance(address, nonce);
        unsignedTx.nonce(nextNonce.toString());
        return unsignedTx;
    }
    /* eslint-disable-next-line max-params */
    async buildTransferTxWithAddress(address, toAddress, amountFlake, nonce, vendorField, manualFee) {
        let nextNonce = nonce;
        if (!nextNonce) {
            nextNonce = await this.nextHydraNonce(address);
        }
        let txn = crypto_1.Transactions.BuilderFactory.transfer()
            .amount(amountFlake.toString())
            .fee((manualFee !== null && manualFee !== void 0 ? manualFee : BigInt(0.1 * 1e8)).toString())
            .nonce(nextNonce.toString())
            .recipientId(toAddress);
        if (vendorField) {
            txn = txn.vendorField(vendorField);
        }
        return txn;
    }
}
exports.Api = Api;
exports.createApi = async (networkConfig) => {
    const api = new Api(new client_1.AxiosClient(networkConfig));
    const [cryptoConfig, height] = await Promise.all([
        api.getNodeCryptoConfig(),
        api.getCurrentHeight(),
    ]);
    crypto_1.Managers.configManager.setConfig(cryptoConfig);
    crypto_1.Managers.configManager.setHeight(height);
    try {
        crypto_1.Transactions.TransactionRegistry.registerTransactionType(transaction_1.MorpheusTransaction);
    }
    catch (e) {
        // using the SDK hot reloaders might call this multiple times in one iteration
        if (!(e instanceof crypto_1.Errors.TransactionAlreadyRegisteredError) &&
            (e.message && e.message.indexOf('Error.captureStackTrace is not a function') === -1)) {
            throw e;
        }
    }
    return api;
};
//# sourceMappingURL=api.js.map