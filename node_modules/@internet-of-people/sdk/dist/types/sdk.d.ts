import * as Crypto from './crypto';
export interface IClonable<T> {
    clone(): T;
}
export interface IContent {
    nonce?: Crypto.Nonce;
}
export declare type ContentId = string;
export declare type Content<T extends IContent> = ContentId | T;
export declare type KeyLink = string;
export declare type DateTime = string;
export declare type Duration = string;
export declare type TransactionId = string;
export declare type Right = string;
export interface IDynamicContent extends IContent {
    [key: string]: unknown;
    schema?: Content<IDynamicContent>;
}
export interface IProcess extends IContent {
    name: string;
    version: number;
    description: string;
    claimSchema: Content<IDynamicContent>;
    evidenceSchema: Content<IDynamicContent> | null;
    constraintsSchema: Content<IDynamicContent> | null;
}
export interface ISignature {
    publicKey: Crypto.PublicKeyData;
    bytes: Crypto.SignatureData;
}
export interface IClaim extends IContent {
    subject: Crypto.DidData;
    content: Content<IDynamicContent>;
}
export interface IWitnessRequest extends IContent {
    claim: IClaim;
    claimant: KeyLink;
    processId: ContentId;
    evidence: Content<IDynamicContent> | null;
}
export interface IWitnessStatement extends IContent {
    claim: Content<IClaim>;
    processId: ContentId;
    constraints: {
        after: DateTime | null;
        before: DateTime | null;
        witness: KeyLink;
        authority: Crypto.DidData;
        content: Content<IDynamicContent> | null;
    };
}
export interface IProvenClaim {
    claim: IClaim;
    statements: ISigned<IWitnessStatement>[];
}
export interface ILicense {
    issuedTo: Crypto.DidData;
    purpose: string;
    validFrom: DateTime;
    validUntil: DateTime;
}
export interface IPresentation extends IContent {
    provenClaims: IProvenClaim[];
    licenses: ILicense[];
}
export interface ISigned<T extends IContent> extends IContent {
    signature: ISignature;
    content: Content<T | IAfterEnvelope<T>>;
}
export interface IPrerequisite {
    process: Content<IProcess>;
    claimFields: string[];
}
export interface ILicenseSpecification {
    issuedTo: Crypto.DidData;
    purpose: string;
    expiry: Duration;
}
export interface IScenario extends IContent {
    name: string;
    version: number;
    description: string;
    prerequisites: IPrerequisite[];
    requiredLicenses: ILicenseSpecification[];
    resultSchema: Content<IDynamicContent> | null;
}
export interface IAfterProof {
    blockHeight: number;
    blockHash: string;
}
export interface IAfterEnvelope<T extends IContent> extends IContent {
    content: Content<T>;
    afterProof: IAfterProof;
}
//# sourceMappingURL=sdk.d.ts.map